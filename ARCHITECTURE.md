# Sui-Drop Architecture

## Overview

Sui-Drop is a stateless, identity-based value transfer protocol that enables users to send tokens to email addresses without requiring recipients to have SUI for gas fees. The system uses zkLogin for identity verification and a self-sustaining relayer model with atomic swaps.

## Core Components

### 1. Stateless Architecture

- **No Database**: All state is derived from URL parameters and on-chain data
- **Master Salt**: Random 32-byte value generated by the sender
- **Address Derivation**: `Hash(JWT_Issuer + Email + Master_Salt)`
- **URL-Based Transfer**: Salt passed via URL hash/query parameters

### 2. zkLogin Integration

- **Google OAuth**: Users authenticate with Google accounts
- **JWT Processing**: Extract issuer and email from JWT tokens
- **Address Computation**: Deterministic address generation from identity
- **Privacy**: Zero-knowledge proofs maintain privacy

### 3. Self-Sustaining Relayer

The relayer pays gas fees upfront and gets reimbursed atomically within the same transaction:

```
Transaction Block Structure:
├── Step A: Atomic Swap
│   └── Swap portion of token (e.g., USDC) → SUI
├── Step B: Reimbursement
│   └── Transfer swapped SUI to relayer address
└── Step C: Token Transfer
    └── Transfer remaining tokens to recipient
```

### 4. Atomic Swap Integration

- **Cetus Protocol**: Uses Cetus DEX for token swaps
- **Slippage Protection**: Minimum output amounts ensure gas coverage
- **Atomic Execution**: All steps happen in a single transaction block
- **Gas Coverage**: Swap amount calculated to cover estimated gas + buffer

## Data Flow

### Link Generation Flow

```
1. Sender enters: Email, Amount, Token Type
2. System generates: Master Salt (random 32 bytes)
3. System creates: Claim URL with salt in hash
4. URL format: /claim#salt=...&email=...&amount=...&token=...
```

### Claim Flow

```
1. Receiver opens claim URL
2. System parses: Salt, Email, Amount, Token from URL
3. Receiver logs in: Google OAuth → JWT token
4. System computes: Address = Hash(Issuer + Email + Salt)
5. System constructs: Transaction Block with atomic swap
6. System sends: Transaction to /api/relay endpoint
7. Relayer verifies: Reimbursement amount >= gas cost
8. Relayer executes: Signs and submits transaction
9. Transaction executes: Swap → Reimburse → Transfer
```

## Security Considerations

### 1. Address Verification

- Recipient address is computed deterministically from JWT + Salt
- Only the person with the correct email can generate the address
- Salt ensures uniqueness even for same email

### 2. Relayer Security

- Relayer private key stored in environment variables (server-side only)
- Reimbursement verification before transaction execution
- Minimum gas reserve to prevent account depletion

### 3. Transaction Validation

- JWT validation before address computation
- Master salt format validation
- Transaction block structure verification
- Reimbursement amount verification

## Implementation Details

### Frontend (Client-Side)

**Pages:**
- `/` - Home page with navigation
- `/generate` - Link generator form
- `/claim` - Claim page with OAuth flow
- `/oauth/callback` - OAuth callback handler

**Hooks:**
- `useZkLogin` - Manages zkLogin authentication state
- `useRelayer` - Handles claim transaction construction

**Utilities:**
- `zk-utils.ts` - zkLogin address computation, JWT handling
- `sui-utils.ts` - Sui SDK helpers, gas estimation
- `cetus-utils.ts` - Cetus swap logic (placeholder for SDK integration)

### Backend (Server-Side)

**API Routes:**
- `/api/relay` - Relayer endpoint for transaction signing

**Utilities:**
- `relayer-utils.ts` - Relayer configuration and execution logic

## Current Limitations & TODOs

### 1. Cetus SDK Integration
- **Status**: Placeholder implementation
- **TODO**: Integrate actual `@cetusprotocol/cetus-sui-clmm-sdk`
- **TODO**: Query pool addresses and current rates
- **TODO**: Handle multiple coin objects properly

### 2. Token Balance Queries
- **Status**: Assumes token availability
- **TODO**: Query user's token balance before transaction
- **TODO**: Handle insufficient balance cases
- **TODO**: Merge coin objects if needed

### 3. Gas Estimation
- **Status**: Simplified estimation
- **TODO**: Use `dryRunTransactionBlock` for accurate estimates
- **TODO**: Add proper error handling

### 4. zkLogin Proof Generation
- **Status**: JWT handling only
- **TODO**: Integrate with Mysten's zkLogin prover service
- **TODO**: Generate proofs before transaction submission

### 5. Transaction Validation
- **Status**: Basic validation
- **TODO**: Parse transaction block to verify recipients
- **TODO**: Verify reimbursement amounts programmatically
- **TODO**: Add rate limiting

## Environment Variables

```env
# Network
NEXT_PUBLIC_SUI_NETWORK=testnet

# Relayer
RELAYER_PRIVATE_KEY=0x...
NEXT_PUBLIC_RELAYER_ADDRESS=0x...

# OAuth
NEXT_PUBLIC_GOOGLE_CLIENT_ID=...

# Optional: Cetus
NEXT_PUBLIC_CETUS_PACKAGE_ID=...
```

## Dependencies

### Core
- `next` - Next.js framework
- `react` - React library
- `typescript` - TypeScript support

### Sui
- `@mysten/sui.js` - Sui JavaScript SDK
- `@mysten/zklogin` - zkLogin utilities
- `@mysten/dapp-kit` - Sui dApp kit

### DEX
- `@cetusprotocol/cetus-sui-clmm-sdk` - Cetus Protocol SDK

### Utilities
- `jwt-decode` - JWT token decoding
- `@noble/hashes` - Cryptographic hashing
- `lucide-react` - Icon library

## Future Enhancements

1. **Multi-Token Support**: Support for more token types
2. **Batch Transfers**: Send to multiple recipients
3. **Scheduled Transfers**: Time-locked transfers
4. **Recurring Payments**: Subscription-like transfers
5. **Analytics Dashboard**: Track transfers and usage
6. **Mobile App**: Native mobile application
7. **Social Features**: Share transfers on social media
8. **Gas Optimization**: More efficient gas usage patterns

